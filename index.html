<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#e26d4a">
    <title>双人趣味五子棋</title>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Source+Sans+3:wght@400;600;700&display=swap");

        :root {
            --ink: #2b2a27;
            --muted: #6b6a63;
            --accent: #e26d4a;
            --accent-dark: #bd4f2f;
            --mint: #88c7b5;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            min-height: 100%;
        }

        body {
            font-family: "Source Sans 3", "Noto Sans SC", sans-serif;
            color: var(--ink);
            background:
                radial-gradient(circle at 12% 10%, rgba(255, 242, 220, 0.9), transparent 45%),
                radial-gradient(circle at 90% 16%, rgba(180, 226, 213, 0.7), transparent 40%),
                linear-gradient(135deg, #f9f2e5 0%, #ecf6f1 60%, #fff5ee 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }

        .page {
            width: min(96vw, 760px);
        }

        .panel {
            background: rgba(255, 255, 255, 0.92);
            border-radius: 1.4rem;
            padding: 1.4rem 1.3rem 1.6rem;
            box-shadow: 0 1.4rem 2.8rem rgba(77, 64, 49, 0.22);
            border: 1px solid rgba(255, 255, 255, 0.7);
            animation: riseIn 0.6s ease both;
            max-width: 760px;
            margin: 0 auto;
        }

        .controls {
            display: grid;
            gap: 0.9rem;
        }

        .name-fields {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 0.7rem;
        }

        .field {
            display: grid;
            gap: 0.35rem;
        }

        .field label {
            font-size: 0.78rem;
            color: var(--muted);
            letter-spacing: 0.08em;
        }

        .field input {
            border: 1px solid #e7d7c0;
            border-radius: 0.8rem;
            padding: 0.6rem 0.75rem;
            font-size: 0.95rem;
            outline: none;
            background: #fffdf9;
        }

        .field input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(226, 109, 74, 0.18);
        }

        .buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 0.6rem;
        }

        .btn {
            border: none;
            border-radius: 999px;
            padding: 0.7rem 1rem;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), #f09a6e);
            color: #fff;
            box-shadow: 0 0.8rem 1.4rem rgba(226, 109, 74, 0.25);
        }

        .btn-ghost {
            background: #f7efe4;
            color: var(--accent-dark);
        }

        .status {
            margin-top: 1rem;
            padding: 0.7rem 0.9rem;
            border-radius: 1rem;
            background: #fff8ef;
            border: 1px dashed #e9c8a8;
            display: grid;
            gap: 0.2rem;
        }

        .turn-text {
            font-size: 0.92rem;
            font-weight: 700;
            color: var(--accent-dark);
        }

        .cursor-text {
            font-size: 0.84rem;
            color: var(--muted);
        }

        .score-text {
            font-size: 0.84rem;
            color: var(--muted);
            font-weight: 600;
        }

        .board-wrap {
            margin-top: 1rem;
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 1.2rem;
            background:
                linear-gradient(145deg, #f2d6b3, #e6c197),
                repeating-linear-gradient(0deg, rgba(126, 88, 53, 0.06) 0 1px, transparent 1px 12px),
                repeating-linear-gradient(90deg, rgba(126, 88, 53, 0.06) 0 1px, transparent 1px 12px);
            box-shadow: inset 0 0 0 1px rgba(111, 82, 50, 0.3), 0 1.2rem 1.8rem rgba(59, 42, 22, 0.22);
            padding: 0;
            max-width: 640px;
            margin-left: auto;
            margin-right: auto;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 0.9rem;
            background: transparent;
        }

        .tips {
            margin-top: 0.9rem;
            font-size: 0.9rem;
            color: var(--muted);
            line-height: 1.6;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-16px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes riseIn {
            from {
                opacity: 0;
                transform: translateY(16px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 720px) {
            body {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <section class="panel">
            <div class="controls">
                <div class="name-fields">
                    <div class="field">
                        <label for="nameA">玩家A（鼠标）</label>
                        <input id="nameA" maxlength="10" placeholder="请输入昵称">
                    </div>
                    <div class="field">
                        <label for="nameB">玩家B（键盘）</label>
                        <input id="nameB" maxlength="10" placeholder="请输入昵称">
                    </div>
                </div>
                <div class="buttons">
                    <button id="undoBtn" class="btn btn-ghost" type="button">悔棋</button>
                    <button id="restartBtn" class="btn btn-primary" type="button">重开一局</button>
                </div>
            </div>

            <div class="status">
                <div id="scoreText" class="score-text">胜场：玩家A 0 - 玩家B 0</div>
                <div id="turnText" class="turn-text">准备就绪</div>
                <div id="cursorText" class="cursor-text">准星坐标：--</div>
            </div>

            <div class="board-wrap">
                <canvas id="board" aria-label="五子棋棋盘"></canvas>
            </div>

            <div class="tips">
                玩家A回合：仅鼠标生效，键盘被禁用。<br>
                玩家B回合：方向键移动准星，回车/空格落子，坐标实时刷新。
            </div>
        </section>
    </div>

    <script>
        const boardSize = 15;
        const board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));
        const moveHistory = [];

        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");
        const turnText = document.getElementById("turnText");
        const cursorText = document.getElementById("cursorText");
        const scoreText = document.getElementById("scoreText");
        const undoBtn = document.getElementById("undoBtn");
        const restartBtn = document.getElementById("restartBtn");
        const nameAInput = document.getElementById("nameA");
        const nameBInput = document.getElementById("nameB");

        let canvasSize = 0;
        let padding = 24;
        let cellSize = 0;
        let currentPlayer = 1;
        let winner = 0;
        let cursor = { x: 7, y: 7 };
        let winsA = 0;
        let winsB = 0;
        let isAnimatingClear = false;
        let clearAnimationProgress = 0;
        const outerMarginCells = 0.45;

        const getName = (player) => {
            const fallback = player === 1 ? "玩家A" : "玩家B";
            const input = player === 1 ? nameAInput.value.trim() : nameBInput.value.trim();
            return input || fallback;
        };

        const clampCursor = () => {
            cursor.x = Math.max(0, Math.min(boardSize - 1, cursor.x));
            cursor.y = Math.max(0, Math.min(boardSize - 1, cursor.y));
        };

        const resizeCanvas = () => {
            const wrap = canvas.parentElement;
            const wrapStyle = window.getComputedStyle(wrap);
            const horizontalPadding = parseFloat(wrapStyle.paddingLeft) + parseFloat(wrapStyle.paddingRight);
            const verticalPadding = parseFloat(wrapStyle.paddingTop) + parseFloat(wrapStyle.paddingBottom);
            const availableWidth = wrap.clientWidth - horizontalPadding;
            const availableHeight = wrap.clientHeight - verticalPadding;
            const targetSize = Math.min(620, Math.max(200, Math.min(availableWidth, availableHeight)));
            const dpr = window.devicePixelRatio || 1;
            const backingSize = Math.round(targetSize * dpr);
            const renderSize = backingSize / dpr;

            canvasSize = renderSize;
            canvas.style.width = `${renderSize}px`;
            canvas.style.height = `${renderSize}px`;
            canvas.width = backingSize;
            canvas.height = backingSize;

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            const spanInCells = (boardSize - 1) + outerMarginCells * 2;
            cellSize = canvasSize / spanInCells;
            padding = outerMarginCells * cellSize;

            drawBoard();
        };

        const drawBoard = () => {
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            ctx.strokeStyle = "rgba(89, 65, 44, 0.65)";
            ctx.lineWidth = 1;
            for (let i = 0; i < boardSize; i += 1) {
                const offset = padding + i * cellSize;
                ctx.beginPath();
                ctx.moveTo(padding, offset);
                ctx.lineTo(canvasSize - padding, offset);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(offset, padding);
                ctx.lineTo(offset, canvasSize - padding);
                ctx.stroke();
            }

            const starPoints = [3, 7, 11];
            ctx.fillStyle = "rgba(60, 42, 24, 0.7)";
            starPoints.forEach((row) => {
                starPoints.forEach((col) => {
                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    ctx.beginPath();
                    ctx.arc(x, y, 3.2, 0, Math.PI * 2);
                    ctx.fill();
                });
            });

            drawPieces();
            drawCursor();
        };

        const drawPieces = () => {
            const pieceAlpha = isAnimatingClear ? Math.max(0, 1 - clearAnimationProgress) : 1;
            ctx.save();
            ctx.globalAlpha = pieceAlpha;
            const pieceRadius = cellSize * 0.42;

            for (let row = 0; row < boardSize; row += 1) {
                for (let col = 0; col < boardSize; col += 1) {
                    const player = board[row][col];
                    if (!player) continue;

                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    const edgeDistance = Math.min(x, y, canvasSize - x, canvasSize - y);
                    const allowShadow = edgeDistance > pieceRadius + 8;
                    ctx.beginPath();
                    ctx.arc(x, y, pieceRadius, 0, Math.PI * 2);
                    if (allowShadow) {
                        ctx.shadowColor = "rgba(58, 40, 20, 0.35)";
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetY = 2;
                    } else {
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    ctx.fillStyle = player === 1 ? "#2b2a27" : "#fff9f2";
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = player === 1 ? "#1b1a18" : "#c9b8a6";
                    ctx.stroke();
                }
            }

            if (moveHistory.length) {
                const last = moveHistory[moveHistory.length - 1];
                const x = padding + last.col * cellSize;
                const y = padding + last.row * cellSize;
                ctx.beginPath();
                ctx.arc(x, y, cellSize * 0.16, 0, Math.PI * 2);
                ctx.fillStyle = last.player === 1 ? "#f3c15b" : "#d26c4a";
                ctx.fill();
            }

            ctx.restore();
        };

        const drawCursor = () => {
            if (currentPlayer !== 2 || winner) return;

            const x = padding + cursor.x * cellSize;
            const y = padding + cursor.y * cellSize;
            const edgeDistance = Math.min(x, y, canvasSize - x, canvasSize - y);
            const safeRadius = Math.max(0, edgeDistance - 2);
            const circleRadius = Math.min(cellSize * 0.46, safeRadius);
            const crossHalf = Math.min(cellSize * 0.55, safeRadius);

            if (circleRadius <= 0 || crossHalf <= 0) return;

            ctx.strokeStyle = "#bd4f2f";
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x - crossHalf, y);
            ctx.lineTo(x + crossHalf, y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, y - crossHalf);
            ctx.lineTo(x, y + crossHalf);
            ctx.stroke();
        };

        const updateStatus = () => {
            if (winner) {
                turnText.textContent = `${getName(winner)} 获胜！`;
            } else {
                const playerName = getName(currentPlayer);
                const inputTip = currentPlayer === 1 ? "鼠标落子" : "键盘落子";
                turnText.textContent = `${playerName} 回合（${inputTip}）`;
            }

            if (currentPlayer === 2 && !winner) {
                cursorText.textContent = `准星坐标：${cursor.x + 1}，${cursor.y + 1}`;
            } else {
                cursorText.textContent = "准星坐标：--";
            }

            scoreText.textContent = `胜场：${getName(1)} ${winsA} - ${getName(2)} ${winsB}`;
        };

        const checkWin = (row, col, player) => {
            const directions = [
                [1, 0],
                [0, 1],
                [1, 1],
                [1, -1]
            ];

            return directions.some(([dx, dy]) => {
                let count = 1;
                let r = row + dy;
                let c = col + dx;

                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) {
                    count += 1;
                    r += dy;
                    c += dx;
                }

                r = row - dy;
                c = col - dx;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && board[r][c] === player) {
                    count += 1;
                    r -= dy;
                    c -= dx;
                }

                return count >= 5;
            });
        };

        const placePiece = (row, col, player) => {
            if (winner || isAnimatingClear || board[row][col] !== 0) return false;

            board[row][col] = player;
            moveHistory.push({ row, col, player });

            if (checkWin(row, col, player)) {
                winner = player;
                if (player === 1) {
                    winsA += 1;
                } else {
                    winsB += 1;
                }
                startClearAnimation();
            } else {
                currentPlayer = player === 1 ? 2 : 1;
            }

            updateStatus();
            drawBoard();
            return true;
        };

        const clearBoardForNextRound = () => {
            for (let row = 0; row < boardSize; row += 1) {
                board[row].fill(0);
            }

            moveHistory.length = 0;
            currentPlayer = 1;
            winner = 0;
            cursor = { x: 7, y: 7 };
        };

        const startClearAnimation = () => {
            isAnimatingClear = true;
            clearAnimationProgress = 0;
            const duration = 750;
            const startTime = performance.now();

            const step = (now) => {
                const elapsed = now - startTime;
                clearAnimationProgress = Math.min(1, elapsed / duration);
                drawBoard();

                if (clearAnimationProgress < 1) {
                    requestAnimationFrame(step);
                    return;
                }

                isAnimatingClear = false;
                clearAnimationProgress = 0;
                clearBoardForNextRound();
                updateStatus();
                drawBoard();
            };

            requestAnimationFrame(step);
        };

        const getCellFromPosition = (clientX, clientY) => {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const col = Math.round((x - padding) / cellSize);
            const row = Math.round((y - padding) / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return null;

            const snapX = padding + col * cellSize;
            const snapY = padding + row * cellSize;
            const distance = Math.hypot(x - snapX, y - snapY);
            if (distance > cellSize * 0.45) return null;

            return { row, col };
        };

        canvas.addEventListener("click", (event) => {
            if (isAnimatingClear || currentPlayer !== 1 || winner) return;

            const cell = getCellFromPosition(event.clientX, event.clientY);
            if (!cell) return;
            placePiece(cell.row, cell.col, 1);
        });

        document.addEventListener("keydown", (event) => {
            const activeTag = document.activeElement?.tagName;
            if (activeTag === "INPUT" || activeTag === "TEXTAREA") return;

            const key = event.key;
            const isBoardKey = key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight" || key === "Enter" || key === " ";

            if (!isBoardKey) return;

            if (winner || isAnimatingClear) {
                event.preventDefault();
                return;
            }

            if (currentPlayer !== 2) {
                event.preventDefault();
                return;
            }

            let moved = false;
            if (key === "ArrowUp") {
                cursor.y -= 1;
                moved = true;
            } else if (key === "ArrowDown") {
                cursor.y += 1;
                moved = true;
            } else if (key === "ArrowLeft") {
                cursor.x -= 1;
                moved = true;
            } else if (key === "ArrowRight") {
                cursor.x += 1;
                moved = true;
            } else if (key === "Enter" || key === " ") {
                event.preventDefault();
                placePiece(cursor.y, cursor.x, 2);
                return;
            }

            if (moved) {
                event.preventDefault();
                clampCursor();
                updateStatus();
                drawBoard();
            }
        });

        undoBtn.addEventListener("click", () => {
            if (isAnimatingClear || !moveHistory.length) return;

            const wasWinningMove = winner !== 0;

            const last = moveHistory.pop();
            board[last.row][last.col] = 0;

            if (wasWinningMove) {
                if (last.player === 1) {
                    winsA = Math.max(0, winsA - 1);
                } else {
                    winsB = Math.max(0, winsB - 1);
                }
            }

            winner = 0;
            currentPlayer = last.player;

            if (currentPlayer === 2) {
                cursor.x = last.col;
                cursor.y = last.row;
            }

            clampCursor();
            updateStatus();
            drawBoard();
        });

        restartBtn.addEventListener("click", () => {
            isAnimatingClear = false;
            clearAnimationProgress = 0;
            for (let row = 0; row < boardSize; row += 1) {
                board[row].fill(0);
            }

            moveHistory.length = 0;
            currentPlayer = 1;
            winner = 0;
            cursor = { x: 7, y: 7 };
            winsA = 0;
            winsB = 0;

            updateStatus();
            drawBoard();
        });

        nameAInput.addEventListener("input", updateStatus);
        nameBInput.addEventListener("input", updateStatus);

        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();
        updateStatus();
    </script>
</body>
</html>
